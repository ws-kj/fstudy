{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nmodule.exports = function base64(alphabet) {\n  // The alphabet is only used to know:\n  //   1. If padding is enabled (must contain '=')\n  //   2. If the output must be url-safe (must contain '-' and '_')\n  //   3. If the input of the output function is valid\n  // The alphabets from RFC 4648 are always used.\n  var padding = alphabet.indexOf('=') > -1;\n  var url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1;\n  return {\n    encode: function encode(input) {\n      var output = '';\n\n      if (typeof input === 'string') {\n        output = Buffer.from(input).toString('base64');\n      } else {\n        output = input.toString('base64');\n      }\n\n      if (url) {\n        output = output.replace('+', '-');\n        output = output.replace('/', '_');\n      }\n\n      var pad = output.indexOf('=');\n\n      if (pad > 0 && !padding) {\n        output = output.substring(0, pad);\n      }\n\n      return output;\n    },\n    decode: function decode(input) {\n      if (url) {\n        input = input.replace('+', '-');\n        input = input.replace('/', '_');\n      }\n\n      var _iterator = _createForOfIteratorHelper(input),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var char = _step.value;\n\n          if (alphabet.indexOf(char) < 0) {\n            throw new Error('invalid base64 character');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return Buffer.from(input, 'base64');\n    }\n  };\n};","map":{"version":3,"sources":["/home/will/src/fstudy/client/node_modules/ipfs-api/node_modules/multibase/src/base64.js"],"names":["module","exports","base64","alphabet","padding","indexOf","url","encode","input","output","Buffer","from","toString","replace","pad","substring","decode","char","Error"],"mappings":"AAAA;;;;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,MAAT,CAAiBC,QAAjB,EAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGD,QAAQ,CAACE,OAAT,CAAiB,GAAjB,IAAwB,CAAC,CAAzC;AACA,MAAMC,GAAG,GAAGH,QAAQ,CAACE,OAAT,CAAiB,GAAjB,IAAwB,CAAC,CAAzB,IAA8BF,QAAQ,CAACE,OAAT,CAAiB,GAAjB,IAAwB,CAAC,CAAnE;AAEA,SAAO;AACLE,IAAAA,MADK,kBACGC,KADH,EACU;AACb,UAAIC,MAAM,GAAG,EAAb;;AAEA,UAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC7BC,QAAAA,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmBI,QAAnB,CAA4B,QAA5B,CAAT;AACD,OAFD,MAEO;AACLH,QAAAA,MAAM,GAAGD,KAAK,CAACI,QAAN,CAAe,QAAf,CAAT;AACD;;AAED,UAAIN,GAAJ,EAAS;AACPG,QAAAA,MAAM,GAAGA,MAAM,CAACI,OAAP,CAAe,GAAf,EAAoB,GAApB,CAAT;AACAJ,QAAAA,MAAM,GAAGA,MAAM,CAACI,OAAP,CAAe,GAAf,EAAoB,GAApB,CAAT;AACD;;AAED,UAAMC,GAAG,GAAGL,MAAM,CAACJ,OAAP,CAAe,GAAf,CAAZ;;AACA,UAAIS,GAAG,GAAG,CAAN,IAAW,CAACV,OAAhB,EAAyB;AACvBK,QAAAA,MAAM,GAAGA,MAAM,CAACM,SAAP,CAAiB,CAAjB,EAAoBD,GAApB,CAAT;AACD;;AAED,aAAOL,MAAP;AACD,KArBI;AAsBLO,IAAAA,MAtBK,kBAsBGR,KAtBH,EAsBU;AACb,UAAIF,GAAJ,EAAS;AACPE,QAAAA,KAAK,GAAGA,KAAK,CAACK,OAAN,CAAc,GAAd,EAAmB,GAAnB,CAAR;AACAL,QAAAA,KAAK,GAAGA,KAAK,CAACK,OAAN,CAAc,GAAd,EAAmB,GAAnB,CAAR;AACD;;AAJY,iDAMIL,KANJ;AAAA;;AAAA;AAMb,4DAAwB;AAAA,cAAfS,IAAe;;AACtB,cAAId,QAAQ,CAACE,OAAT,CAAiBY,IAAjB,IAAyB,CAA7B,EAAgC;AAC9B,kBAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACD;AACF;AAVY;AAAA;AAAA;AAAA;AAAA;;AAYb,aAAOR,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmB,QAAnB,CAAP;AACD;AAnCI,GAAP;AAqCD,CA9CD","sourcesContent":["'use strict'\n\nmodule.exports = function base64 (alphabet) {\n  // The alphabet is only used to know:\n  //   1. If padding is enabled (must contain '=')\n  //   2. If the output must be url-safe (must contain '-' and '_')\n  //   3. If the input of the output function is valid\n  // The alphabets from RFC 4648 are always used.\n  const padding = alphabet.indexOf('=') > -1\n  const url = alphabet.indexOf('-') > -1 && alphabet.indexOf('_') > -1\n\n  return {\n    encode (input) {\n      let output = ''\n\n      if (typeof input === 'string') {\n        output = Buffer.from(input).toString('base64')\n      } else {\n        output = input.toString('base64')\n      }\n\n      if (url) {\n        output = output.replace('+', '-')\n        output = output.replace('/', '_')\n      }\n\n      const pad = output.indexOf('=')\n      if (pad > 0 && !padding) {\n        output = output.substring(0, pad)\n      }\n\n      return output\n    },\n    decode (input) {\n      if (url) {\n        input = input.replace('+', '-')\n        input = input.replace('/', '_')\n      }\n\n      for (let char of input) {\n        if (alphabet.indexOf(char) < 0) {\n          throw new Error('invalid base64 character')\n        }\n      }\n\n      return Buffer.from(input, 'base64')\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}