{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/wskj/src/fstudy/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/wskj/src/fstudy/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/wskj/src/fstudy/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/wskj/src/fstudy/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Transform = require('stream').Transform;\n\nvar isNode = require('detect-node');\n\nvar isSource = require('is-pull-stream').isSource;\n\nvar toStream = require('pull-stream-to-stream');\n\nvar PADDING = '--';\nvar NEW_LINE = '\\r\\n';\nvar NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\n\nvar Multipart = /*#__PURE__*/function (_Transform) {\n  _inherits(Multipart, _Transform);\n\n  var _super = _createSuper(Multipart);\n\n  function Multipart(options) {\n    var _this;\n\n    _classCallCheck(this, Multipart);\n\n    _this = _super.call(this, Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    }));\n    _this._boundary = _this._generateBoundary();\n    _this._files = [];\n    _this._draining = false;\n    return _this;\n  }\n\n  _createClass(Multipart, [{\n    key: \"_flush\",\n    value: function _flush() {\n      this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n      this.push(null);\n    }\n  }, {\n    key: \"_generateBoundary\",\n    value: function _generateBoundary() {\n      var boundary = '--------------------------';\n\n      for (var i = 0; i < 24; i++) {\n        boundary += Math.floor(Math.random() * 10).toString(16);\n      }\n\n      return boundary;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(file, encoding, callback) {\n      if (Buffer.isBuffer(file)) {\n        this.push(file);\n        return callback(); // early\n      } // not a buffer, must be a file\n\n\n      this._files.push(file);\n\n      this._maybeDrain(callback);\n    }\n  }, {\n    key: \"_maybeDrain\",\n    value: function _maybeDrain(callback) {\n      var _this2 = this;\n\n      if (!this._draining) {\n        if (this._files.length) {\n          this._draining = true;\n\n          var file = this._files.shift();\n\n          this._pushFile(file, function (err) {\n            _this2._draining = false;\n\n            if (err) {\n              _this2.emit('error', err);\n            } else {\n              _this2._maybeDrain(callback);\n            }\n          });\n        } else {\n          this.emit('drained all files');\n          callback();\n        }\n      } else {\n        this.once('drained all files', callback);\n      }\n    }\n  }, {\n    key: \"_pushFile\",\n    value: function _pushFile(file, callback) {\n      var _this3 = this;\n\n      var leading = this._leading(file.headers || {});\n\n      this.push(leading);\n      var content = file.content || Buffer.alloc(0);\n\n      if (Buffer.isBuffer(content)) {\n        this.push(content);\n        this.push(NEW_LINE_BUFFER);\n        return callback(); // early\n      }\n\n      if (isSource(content)) {\n        content = toStream.source(content);\n      } // From now on we assume content is a stream\n\n\n      content.once('error', this.emit.bind(this, 'error'));\n      content.once('end', function () {\n        _this3.push(NEW_LINE_BUFFER);\n\n        callback(); // TODO: backpressure!!! wait once self is drained so we can proceed\n        // This does not work\n        // this.once('drain', () => {\n        //   callback()\n        // })\n      });\n      content.on('data', function (data) {\n        var drained = _this3.push(data); // Only do the drain dance on Node.js.\n        // In browserland, the underlying stream\n        // does NOT drain because the request is only sent\n        // once this stream ends.\n\n\n        if (!drained && isNode) {\n          content.pause();\n\n          _this3.once('drain', function () {\n            return content.resume();\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_leading\",\n    value: function _leading(headers) {\n      var leading = [PADDING + this._boundary];\n      Object.keys(headers).forEach(function (header) {\n        leading.push(header + ': ' + headers[header]);\n      });\n      leading.push('');\n      leading.push('');\n      var leadingStr = leading.join(NEW_LINE);\n      return Buffer.from(leadingStr);\n    }\n  }]);\n\n  return Multipart;\n}(Transform);\n\nmodule.exports = Multipart;","map":{"version":3,"sources":["/home/wskj/src/node_modules/ipfs-api/src/utils/multipart.js"],"names":["Transform","require","isNode","isSource","toStream","PADDING","NEW_LINE","NEW_LINE_BUFFER","Buffer","from","Multipart","options","Object","assign","objectMode","highWaterMark","_boundary","_generateBoundary","_files","_draining","push","boundary","i","Math","floor","random","toString","file","encoding","callback","isBuffer","_maybeDrain","length","shift","_pushFile","err","emit","once","leading","_leading","headers","content","alloc","source","bind","on","data","drained","pause","resume","keys","forEach","header","leadingStr","join","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Transform = require('stream').Transform\nconst isNode = require('detect-node')\nconst isSource = require('is-pull-stream').isSource\nconst toStream = require('pull-stream-to-stream')\n\nconst PADDING = '--'\nconst NEW_LINE = '\\r\\n'\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE)\n\nclass Multipart extends Transform {\n  constructor (options) {\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 1 }))\n\n    this._boundary = this._generateBoundary()\n    this._files = []\n    this._draining = false\n  }\n\n  _flush () {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE))\n    this.push(null)\n  }\n\n  _generateBoundary () {\n    var boundary = '--------------------------'\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16)\n    }\n\n    return boundary\n  }\n\n  _transform (file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file)\n      return callback() // early\n    }\n    // not a buffer, must be a file\n    this._files.push(file)\n    this._maybeDrain(callback)\n  }\n\n  _maybeDrain (callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true\n        const file = this._files.shift()\n        this._pushFile(file, (err) => {\n          this._draining = false\n          if (err) {\n            this.emit('error', err)\n          } else {\n            this._maybeDrain(callback)\n          }\n        })\n      } else {\n        this.emit('drained all files')\n        callback()\n      }\n    } else {\n      this.once('drained all files', callback)\n    }\n  }\n\n  _pushFile (file, callback) {\n    const leading = this._leading(file.headers || {})\n\n    this.push(leading)\n\n    let content = file.content || Buffer.alloc(0)\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content)\n      this.push(NEW_LINE_BUFFER)\n      return callback() // early\n    }\n\n    if (isSource(content)) {\n      content = toStream.source(content)\n    }\n\n    // From now on we assume content is a stream\n\n    content.once('error', this.emit.bind(this, 'error'))\n\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER)\n      callback()\n\n      // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    })\n\n    content.on('data', (data) => {\n      const drained = this.push(data)\n      // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n      if (!drained && isNode) {\n        content.pause()\n        this.once('drain', () => content.resume())\n      }\n    })\n  }\n\n  _leading (headers) {\n    var leading = [PADDING + this._boundary]\n\n    Object.keys(headers).forEach((header) => {\n      leading.push(header + ': ' + headers[header])\n    })\n\n    leading.push('')\n    leading.push('')\n\n    const leadingStr = leading.join(NEW_LINE)\n\n    return Buffer.from(leadingStr)\n  }\n}\n\nmodule.exports = Multipart\n"]},"metadata":{},"sourceType":"script"}