{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _classCallCheck = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar mh = require('multihashes');\n\nvar crypto = require('libp2p-crypto');\n\nvar assert = require('assert');\n\nvar waterfall = require('async/waterfall');\n\nvar PeerId = /*#__PURE__*/function () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    } // Return the protobuf version of the public key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPubKey\",\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return crypto.keys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return crypto.keys.marshalPrivateKey(this.privKey);\n      }\n    } // pretty print\n\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      return this.toJSON();\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return mh.toHexString(this.id);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      if (Buffer.isBuffer(id)) {\n        return this.id.equals(id);\n      } else if (id.id) {\n        return this.id.equals(id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(callback) {\n      // TODO Needs better checking\n      if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n        callback();\n      } else {\n        callback(new Error('Keys not match'));\n      }\n    }\n  }]);\n\n  return PeerId;\n}();\n\nexports = module.exports = PeerId; // generation\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  waterfall([function (cb) {\n    return crypto.keys.generateKeyPair('RSA', opts.bits, cb);\n  }, function (privKey, cb) {\n    return privKey.public.hash(function (err, digest) {\n      cb(err, digest, privKey);\n    });\n  }], function (err, digest, privKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey));\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var pubKey;\n\n  try {\n    var buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = crypto.keys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  pubKey.hash(function (err, digest) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, null, pubKey));\n  });\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  waterfall([function (cb) {\n    return crypto.keys.unmarshalPrivateKey(buf, cb);\n  }, function (privKey, cb) {\n    return privKey.public.hash(function (err, digest) {\n      cb(err, digest, privKey);\n    });\n  }], function (err, digest, privKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public));\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var id;\n  var rawPrivKey;\n  var rawPubKey;\n  var pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (rawPrivKey) {\n    waterfall([function (cb) {\n      return crypto.keys.unmarshalPrivateKey(rawPrivKey, cb);\n    }, function (priv, cb) {\n      return priv.public.hash(function (err, digest) {\n        cb(err, digest, priv);\n      });\n    }, function (privDigest, priv, cb) {\n      if (pub) {\n        pub.hash(function (err, pubDigest) {\n          cb(err, privDigest, priv, pubDigest);\n        });\n      } else {\n        cb(null, privDigest, priv);\n      }\n    }], function (err, privDigest, priv, pubDigest) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'));\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'));\n      }\n\n      callback(null, new PeerId(id, priv, pub));\n    });\n  } else {\n    callback(null, new PeerId(id, null, pub));\n  }\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["/home/will/src/fstudy/client/node_modules/peer-info/node_modules/peer-id/src/index.js"],"names":["mh","require","crypto","assert","waterfall","PeerId","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","keys","marshalPublicKey","marshalPrivateKey","toJSON","toB64Opt","marshalPrivKey","marshalPubKey","toHexString","callback","exports","module","create","opts","bits","cb","generateKeyPair","hash","err","digest","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","unmarshalPublicKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst crypto = require('libp2p-crypto')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // pretty print\n  toPrint () {\n    return this.toJSON()\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nexports = module.exports = PeerId\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n\n  waterfall([\n    (cb) => crypto.keys.generateKeyPair('RSA', opts.bits, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey))\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = crypto.keys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, null, pubKey))\n  })\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  waterfall([\n    (cb) => crypto.keys.unmarshalPrivateKey(buf, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public))\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (rawPrivKey) {\n    waterfall([\n      (cb) => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb),\n      (priv, cb) => priv.public.hash((err, digest) => {\n        cb(err, digest, priv)\n      }),\n      (privDigest, priv, cb) => {\n        if (pub) {\n          pub.hash((err, pubDigest) => {\n            cb(err, privDigest, priv, pubDigest)\n          })\n        } else {\n          cb(null, privDigest, priv)\n        }\n      }\n    ], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'))\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'))\n      }\n\n      callback(null, new PeerId(id, priv, pub))\n    })\n  } else {\n    callback(null, new PeerId(id, null, pub))\n  }\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}