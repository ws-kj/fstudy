{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar ensureMultiaddr = require('./utils').ensureMultiaddr;\n\nvar uniqBy = require('lodash.uniqby'); // Because JavaScript doesn't let you overload the compare in Set()..\n\n\nvar MultiaddrSet = /*#__PURE__*/function () {\n  function MultiaddrSet(multiaddrs) {\n    _classCallCheck(this, MultiaddrSet);\n\n    this._multiaddrs = multiaddrs || [];\n    this._observedMultiaddrs = [];\n  }\n\n  _createClass(MultiaddrSet, [{\n    key: \"add\",\n    value: function add(ma) {\n      ma = ensureMultiaddr(ma);\n\n      if (!this.has(ma)) {\n        this._multiaddrs.push(ma);\n      }\n    } // addSafe - prevent multiaddr explosion™\n    // Multiaddr explosion is when you dial to a bunch of nodes and every node\n    // gives you a different observed address and you start storing them all to\n    // share with other peers. This seems like a good idea until you realize that\n    // most of those addresses are unique to the subnet that peer is in and so,\n    // they are completely worthless for all the other peers. This method is\n    // exclusively used by identify.\n\n  }, {\n    key: \"addSafe\",\n    value: function addSafe(ma) {\n      var _this = this;\n\n      ma = ensureMultiaddr(ma);\n\n      var check = this._observedMultiaddrs.some(function (m, i) {\n        if (m.equals(ma)) {\n          _this.add(ma);\n\n          _this._observedMultiaddrs.splice(i, 1);\n\n          return true;\n        }\n      });\n\n      if (!check) {\n        this._observedMultiaddrs.push(ma);\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this._multiaddrs.slice();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._multiaddrs.length;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      return this._multiaddrs.forEach(fn);\n    }\n  }, {\n    key: \"filterBy\",\n    value: function filterBy(maFmt) {\n      if (typeof maFmt !== 'object' || typeof maFmt.matches !== 'function' || typeof maFmt.partialMatch !== 'function' || typeof maFmt.toString !== 'function') return [];\n      return this._multiaddrs.filter(function (ma) {\n        return maFmt.matches(ma);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(ma) {\n      ma = ensureMultiaddr(ma);\n      return this._multiaddrs.some(function (m) {\n        return m.equals(ma);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(ma) {\n      var _this2 = this;\n\n      ma = ensureMultiaddr(ma);\n\n      this._multiaddrs.some(function (m, i) {\n        if (m.equals(ma)) {\n          _this2._multiaddrs.splice(i, 1);\n\n          return true;\n        }\n      });\n    } // replaces selected existing multiaddrs with new ones\n\n  }, {\n    key: \"replace\",\n    value: function replace(existing, fresh) {\n      var _this3 = this;\n\n      if (!Array.isArray(existing)) {\n        existing = [existing];\n      }\n\n      if (!Array.isArray(fresh)) {\n        fresh = [fresh];\n      }\n\n      existing.forEach(function (m) {\n        return _this3.delete(m);\n      });\n      fresh.forEach(function (m) {\n        return _this3.add(m);\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._multiaddrs = [];\n    } // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n    // different\n    // TODO this is not an ideal solution, probably this code should just be\n    // in libp2p-tcp\n\n  }, {\n    key: \"distinct\",\n    value: function distinct() {\n      return uniqBy(this._multiaddrs, function (ma) {\n        return [ma.toOptions().port, ma.toOptions().transport].join();\n      });\n    }\n  }]);\n\n  return MultiaddrSet;\n}();\n\nmodule.exports = MultiaddrSet;","map":{"version":3,"sources":["/home/will/src/fstudy/client/node_modules/peer-info/src/multiaddr-set.js"],"names":["ensureMultiaddr","require","uniqBy","MultiaddrSet","multiaddrs","_multiaddrs","_observedMultiaddrs","ma","has","push","check","some","m","i","equals","add","splice","slice","length","fn","forEach","maFmt","matches","partialMatch","toString","filter","existing","fresh","Array","isArray","delete","toOptions","port","transport","join","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ensureMultiaddr = require('./utils').ensureMultiaddr\nconst uniqBy = require('lodash.uniqby')\n\n// Because JavaScript doesn't let you overload the compare in Set()..\nclass MultiaddrSet {\n  constructor (multiaddrs) {\n    this._multiaddrs = multiaddrs || []\n    this._observedMultiaddrs = []\n  }\n\n  add (ma) {\n    ma = ensureMultiaddr(ma)\n\n    if (!this.has(ma)) {\n      this._multiaddrs.push(ma)\n    }\n  }\n\n  // addSafe - prevent multiaddr explosion™\n  // Multiaddr explosion is when you dial to a bunch of nodes and every node\n  // gives you a different observed address and you start storing them all to\n  // share with other peers. This seems like a good idea until you realize that\n  // most of those addresses are unique to the subnet that peer is in and so,\n  // they are completely worthless for all the other peers. This method is\n  // exclusively used by identify.\n  addSafe (ma) {\n    ma = ensureMultiaddr(ma)\n\n    const check = this._observedMultiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this.add(ma)\n        this._observedMultiaddrs.splice(i, 1)\n        return true\n      }\n    })\n    if (!check) {\n      this._observedMultiaddrs.push(ma)\n    }\n  }\n\n  toArray () {\n    return this._multiaddrs.slice()\n  }\n\n  get size () {\n    return this._multiaddrs.length\n  }\n\n  forEach (fn) {\n    return this._multiaddrs.forEach(fn)\n  }\n\n  filterBy (maFmt) {\n    if (typeof maFmt !== 'object' ||\n      typeof maFmt.matches !== 'function' ||\n      typeof maFmt.partialMatch !== 'function' ||\n      typeof maFmt.toString !== 'function') return []\n\n    return this._multiaddrs.filter((ma) => maFmt.matches(ma))\n  }\n\n  has (ma) {\n    ma = ensureMultiaddr(ma)\n    return this._multiaddrs.some((m) => m.equals(ma))\n  }\n\n  delete (ma) {\n    ma = ensureMultiaddr(ma)\n\n    this._multiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this._multiaddrs.splice(i, 1)\n        return true\n      }\n    })\n  }\n\n  // replaces selected existing multiaddrs with new ones\n  replace (existing, fresh) {\n    if (!Array.isArray(existing)) {\n      existing = [existing]\n    }\n    if (!Array.isArray(fresh)) {\n      fresh = [fresh]\n    }\n    existing.forEach((m) => this.delete(m))\n    fresh.forEach((m) => this.add(m))\n  }\n\n  clear () {\n    this._multiaddrs = []\n  }\n\n  // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n  // different\n  // TODO this is not an ideal solution, probably this code should just be\n  // in libp2p-tcp\n  distinct () {\n    return uniqBy(this._multiaddrs, (ma) => {\n      return [ma.toOptions().port, ma.toOptions().transport].join()\n    })\n  }\n}\n\nmodule.exports = MultiaddrSet\n"]},"metadata":{},"sourceType":"script"}