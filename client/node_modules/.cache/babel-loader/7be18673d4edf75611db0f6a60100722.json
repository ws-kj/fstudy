{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/will/src/fstudy/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar mh = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar codecs = require('multicodec/src/base-table');\n\nvar CIDUtil = require('./cid-util');\n\nvar withIs = require('class-is');\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n *\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\n\n\nvar CID = /*#__PURE__*/function () {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   *\n   * ..if only JS had traits..\n   * ```\n   *\n   * @param {string|Buffer} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   *\n   * @example\n   *\n   * new CID(<version>, <codec>, <multihash>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   *\n   */\n  function CID(version, codec, multihash) {\n    _classCallCheck(this, CID);\n\n    if (module.exports.isCID(version)) {\n      var cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash);\n      return;\n    }\n\n    if (typeof version === 'string') {\n      if (multibase.isEncoded(version)) {\n        // CID String (encoded with multibase)\n        var _cid = multibase.decode(version);\n\n        version = parseInt(_cid.slice(0, 1).toString('hex'), 16);\n        codec = multicodec.getCodec(_cid.slice(1));\n        multihash = multicodec.rmPrefix(_cid.slice(1));\n      } else {\n        // bs58 string encoded multihash\n        codec = 'dag-pb';\n        multihash = mh.fromB58String(version);\n        version = 0;\n      }\n    } else if (Buffer.isBuffer(version)) {\n      var firstByte = version.slice(0, 1);\n      var v = parseInt(firstByte.toString('hex'), 16);\n\n      if (v === 0 || v === 1) {\n        // CID\n        var _cid2 = version;\n        version = v;\n        codec = multicodec.getCodec(_cid2.slice(1));\n        multihash = multicodec.rmPrefix(_cid2.slice(1));\n      } else {\n        // multihash\n        codec = 'dag-pb';\n        multihash = version;\n        version = 0;\n      }\n    }\n    /**\n     * @type {string}\n     */\n\n\n    this.codec = codec;\n    /**\n     * @type {number}\n     */\n\n    this.version = version;\n    /**\n     * @type {Buffer}\n     */\n\n    this.multihash = multihash;\n    CID.validateCID(this);\n  }\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n\n\n  _createClass(CID, [{\n    key: \"buffer\",\n    get: function get() {\n      var buffer = this._buffer;\n\n      if (!buffer) {\n        if (this.version === 0) {\n          buffer = this.multihash;\n        } else if (this.version === 1) {\n          buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n        } else {\n          throw new Error('unsupported version');\n        } // Cache this buffer so it doesn't have to be recreated\n\n\n        Object.defineProperty(this, '_buffer', {\n          value: buffer\n        });\n      }\n\n      return buffer;\n    }\n    /**\n     * Get the prefix of the CID.\n     *\n     * @returns {Buffer}\n     * @readonly\n     */\n\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return Buffer.concat([Buffer.from(\"0\".concat(this.version), 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n    }\n    /**\n     * Convert to a CID of version `0`.\n     *\n     * @returns {CID}\n     */\n\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n\n      var _mh$decode = mh.decode(this.multihash),\n          name = _mh$decode.name,\n          length = _mh$decode.length;\n\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n\n      return new _CID(0, this.codec, this.multihash);\n    }\n    /**\n     * Convert to a CID of version `1`.\n     *\n     * @returns {CID}\n     */\n\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new _CID(1, this.codec, this.multihash);\n    }\n    /**\n     * Encode the CID into a string.\n     *\n     * @param {string} [base='base58btc'] - Base encoding to use.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString(base) {\n      base = base || 'base58btc';\n\n      switch (this.version) {\n        case 0:\n          {\n            if (base !== 'base58btc') {\n              throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n            }\n\n            return mh.toB58String(this.multihash);\n          }\n\n        case 1:\n          return multibase.encode(base, this.buffer).toString();\n\n        default:\n          throw new Error('Unsupported version');\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n    /**\n     * Serialize to a plain object.\n     *\n     * @returns {SerializedCID}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n    /**\n     * Compare equality with another CID.\n     *\n     * @param {CID} other\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n    }\n    /**\n     * Test if the given input is a valid CID object.\n     * Throws if it is not.\n     *\n     * @param {any} other\n     * @returns {void}\n     */\n\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n  }]);\n\n  return CID;\n}();\n\nvar _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"sources":["/home/will/src/fstudy/client/node_modules/cids/src/index.js"],"names":["mh","require","multibase","multicodec","codecs","CIDUtil","withIs","CID","version","codec","multihash","module","exports","isCID","cid","Buffer","from","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","isBuffer","firstByte","v","validateCID","buffer","_buffer","concat","getCodeVarint","Error","Object","defineProperty","value","prefix","name","length","_CID","base","toB58String","encode","toBaseEncodedString","hash","other","equals","errorMsg","checkCIDComponents","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst codecs = require('multicodec/src/base-table')\nconst CIDUtil = require('./cid-util')\nconst withIs = require('class-is')\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n *\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   *\n   * ..if only JS had traits..\n   * ```\n   *\n   * @param {string|Buffer} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   *\n   * @example\n   *\n   * new CID(<version>, <codec>, <multihash>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   *\n   */\n  constructor (version, codec, multihash) {\n    if (module.exports.isCID(version)) {\n      let cid = version\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = Buffer.from(cid.multihash)\n      return\n    }\n    if (typeof version === 'string') {\n      if (multibase.isEncoded(version)) { // CID String (encoded with multibase)\n        const cid = multibase.decode(version)\n        version = parseInt(cid.slice(0, 1).toString('hex'), 16)\n        codec = multicodec.getCodec(cid.slice(1))\n        multihash = multicodec.rmPrefix(cid.slice(1))\n      } else { // bs58 string encoded multihash\n        codec = 'dag-pb'\n        multihash = mh.fromB58String(version)\n        version = 0\n      }\n    } else if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1)\n      const v = parseInt(firstByte.toString('hex'), 16)\n      if (v === 0 || v === 1) { // CID\n        const cid = version\n        version = v\n        codec = multicodec.getCodec(cid.slice(1))\n        multihash = multicodec.rmPrefix(cid.slice(1))\n      } else { // multihash\n        codec = 'dag-pb'\n        multihash = version\n        version = 0\n      }\n    }\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec\n\n    /**\n     * @type {number}\n     */\n    this.version = version\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get buffer () {\n    let buffer = this._buffer\n\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([\n          Buffer.from('01', 'hex'),\n          multicodec.getCodeVarint(this.codec),\n          this.multihash\n        ])\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', { value: buffer })\n    }\n\n    return buffer\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n  get prefix () {\n    return Buffer.concat([\n      Buffer.from(`0${this.version}`, 'hex'),\n      multicodec.getCodeVarint(this.codec),\n      mh.prefix(this.multihash)\n    ])\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new _CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new _CID(1, this.codec, this.multihash)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base='base58btc'] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base) {\n    base = base || 'base58btc'\n\n    switch (this.version) {\n      case 0: {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n        }\n        return mh.toB58String(this.multihash)\n      }\n      case 1:\n        return multibase.encode(base, this.buffer).toString()\n      default:\n        throw new Error('Unsupported version')\n    }\n  }\n\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      this.multihash.equals(other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID (other) {\n    let errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n})\n\n_CID.codecs = codecs\n\nmodule.exports = _CID\n"]},"metadata":{},"sourceType":"script"}